use rand::RngCore;
use rand::SeedableRng;
/**
 * This file provides some basic functionality that you can use.
 * DO NOT EDIT THIS FILE EXCEPT FOR Color::cross().
 */
use rand_pcg::Pcg64;
use std::cell::RefCell;

thread_local!(
    pub static RNG: RefCell<Pcg64> = RefCell::new(Pcg64::seed_from_u64(0));
);

fn rand32() -> u32 {
    RNG.with(|r| (*r.borrow_mut()).next_u32())
}

// Chooses bits at random from each of x and y.
pub fn cross32(x: u32, y: u32) -> u32 {
    let r: u32 = rand32();

    // ! is bitwise not in Rust.
    (x & r) + (y & !r)
}

// Chooses bits at random from each of x and y.
pub fn cross8(x: u8, y: u8) -> u8 {
    let r: u8 = (rand32() & 0xff) as u8;

    // ! is bitwise not in Rust.
    (x & r) + (y & !r)
}

// Basic flavor preferences
#[derive(Debug, PartialEq, Copy, Clone)]
pub enum Flavor {
    Sour,
    Sweet,
    Salty,
    Bitter,
    Umami,
}

impl Flavor {
    pub fn random_flavor() -> Flavor {
        let r: u32 = rand32() % 5;
        match r {
            0 => Flavor::Sour,
            1 => Flavor::Sweet,
            2 => Flavor::Salty,
            3 => Flavor::Bitter,
            4 => Flavor::Umami,
            _ => panic!("bug in random_flavor"),
        }
    }
}

// Colors
#[derive(Eq, PartialEq, Debug)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}

impl Color {
    pub fn new(r: u8, g: u8, b: u8) -> Color {
        Color { r, g, b }
    }

    /**
     * Returns a new Color whose components have been computed by calling cross8 on the components of c1 and c2.
     */
    pub fn cross(c1: &Color, c2: &Color) -> Color {
        let r = cross8(c1.r,c2.r);
        let g = cross8(c1.g,c2.g);
        let b = cross8(c1.b,c2.b);
        Color::new(r,g,b)
    }
}
